const { Client, LocalAuth, MessageMedia } = require('whatsapp-web.js');
const qrcode = require('qrcode-terminal');
const fs = require('fs');
const path = require('path');
const moment = require('moment');

// Configura√ß√£o do cliente com op√ß√µes otimizadas para ambiente de servidor
const puppeteerOptions = {
  args: [
    '--no-sandbox',
    '--disable-setuid-sandbox',
    '--disable-dev-shm-usage',
    '--disable-accelerated-2d-canvas',
    '--no-first-run',
    '--no-zygote',
    '--single-process',
    '--disable-gpu'
  ],
  headless: true
};

// Configura√ß√£o do cliente
const client = new Client({
  authStrategy: new LocalAuth({
    dataPath: './whatsapp-session' // Caminho para armazenar dados de sess√£o
  }),
  puppeteer: puppeteerOptions
});

// Estruturas de dados
let gastos = [];
let categorias = {
  'alimenta√ß√£o': ['comida', 'restaurante', 'lanche', 'mercado', 'supermercado', 'feira', 'delivery'],
  'transporte': ['uber', 't√°xi', '99', 'gasolina', 'combust√≠vel', 'estacionamento', 'metr√¥', '√¥nibus', 'passagem'],
  'moradia': ['aluguel', 'condom√≠nio', '√°gua', 'luz', 'energia', 'g√°s', 'internet', 'iptu'],
  'lazer': ['cinema', 'teatro', 'show', 'viagem', 'passeio', 'streaming', 'netflix', 'spotify'],
  'sa√∫de': ['rem√©dio', 'farm√°cia', 'm√©dico', 'consulta', 'exame', 'academia', 'dentista'],
  'educa√ß√£o': ['curso', 'livro', 'faculdade', 'escola', 'material', 'mensalidade'],
  'compras': ['roupa', 'sapato', 'eletr√¥nico', 'celular', 'presente', 'shopping'],
  'outros': []
};

let orcamentos = {};
let chatProprio = null; // Armazena o ID do chat pr√≥prio

// Lista de contatos permitidos (n√∫meros de telefone com c√≥digo do pa√≠s)
const contatosPermitidos = [];

// Diret√≥rio para salvar imagens de comprovantes
const diretorioComprovantes = path.join(__dirname, 'comprovantes');
if (!fs.existsSync(diretorioComprovantes)) {
  fs.mkdirSync(diretorioComprovantes, { recursive: true });
}

// Fun√ß√£o para garantir que os arquivos de dados existam
function inicializarArquivos() {
  const arquivos = {
    'gastos.json': [],
    'categorias.json': categorias,
    'orcamentos.json': {},
    'contatos_permitidos.json': []
  };

  for (const [arquivo, valorPadrao] of Object.entries(arquivos)) {
    if (!fs.existsSync(arquivo)) {
      fs.writeFileSync(arquivo, JSON.stringify(valorPadrao, null, 2));
      console.log(`Arquivo ${arquivo} criado com valores padr√£o`);
    }
  }
}

// Inicializar arquivos
inicializarArquivos();

// Carregar dados se j√° existirem
try {
  if (fs.existsSync('gastos.json')) {
    gastos = JSON.parse(fs.readFileSync('gastos.json'));
    console.log(`‚úÖ ${gastos.length} gastos carregados`);
  }

  if (fs.existsSync('categorias.json')) {
    categorias = JSON.parse(fs.readFileSync('categorias.json'));
    console.log('‚úÖ Categorias carregadas');
  }

  if (fs.existsSync('orcamentos.json')) {
    orcamentos = JSON.parse(fs.readFileSync('orcamentos.json'));
    console.log('‚úÖ Or√ßamentos carregados');
  }

  if (fs.existsSync('chat_proprio.json')) {
    chatProprio = JSON.parse(fs.readFileSync('chat_proprio.json')).chatId;
    console.log('‚úÖ Chat pr√≥prio carregado:', chatProprio);
  }

  if (fs.existsSync('contatos_permitidos.json')) {
    const contatosCarregados = JSON.parse(fs.readFileSync('contatos_permitidos.json'));
    contatosPermitidos.push(...contatosCarregados);
    console.log('‚úÖ Lista de contatos permitidos carregada:', contatosPermitidos);
  }
} catch (error) {
  console.error('‚ùå Erro ao carregar dados:', error);
}

/* === QR code === */
client.on('qr', (qr) => {
  // Gerar QR code no terminal
  qrcode.generate(qr, { small: true });
  console.log('QR CODE STRING:', qr);
  
  // Tamb√©m registrar o QR code no console para poder visualizar nos logs do servidor
  console.log('QR CODE GERADO. Escaneie com seu WhatsApp:');
  console.log(qr);
});

/* === Pronto === */
client.on('ready', () => {
  console.log('‚úÖ Bot est√° pronto!');
});

/* === Reconex√£o === */
client.on('disconnected', (reason) => {
  console.log('Bot desconectado:', reason);
  console.log('Tentando reconectar...');
  client.initialize();
});

/* === Fun√ß√µes Auxiliares === */

// Fun√ß√£o para categorizar automaticamente um gasto
function categorizarGasto(descricao) {
  descricao = descricao.toLowerCase();
  
  for (const [categoria, palavrasChave] of Object.entries(categorias)) {
    for (const palavra of palavrasChave) {
      if (descricao.includes(palavra.toLowerCase())) {
        return categoria;
      }
    }
  }
  
  return 'outros';
}

// Fun√ß√£o para formatar data
function formatarData(dataISO) {
  return moment(dataISO).format('DD/MM/YYYY');
}

// Fun√ß√£o para calcular gastos por categoria
function gastosPorCategoria() {
  const resultado = {};
  
  gastos.forEach(gasto => {
    const categoria = gasto.categoria;
    if (!resultado[categoria]) {
      resultado[categoria] = 0;
    }
    resultado[categoria] += gasto.valor;
  });
  
  return resultado;
}

// Fun√ß√£o para calcular gastos por per√≠odo
function gastosPorPeriodo(periodo) {
  const hoje = moment();
  const dataInicio = periodo === 'mes' ? 
    moment().startOf('month') : 
    periodo === 'semana' ? 
      moment().startOf('week') : 
      periodo === 'ano' ? 
        moment().startOf('year') : 
        moment().subtract(1, 'days');
  
  return gastos.filter(gasto => {
    const dataGasto = moment(gasto.data);
    return dataGasto.isSameOrAfter(dataInicio) && dataGasto.isSameOrBefore(hoje);
  });
}

// Fun√ß√£o para verificar se um or√ßamento foi excedido
function verificarOrcamentos() {
  const gastosDoMes = gastosPorPeriodo('mes');
  const totalPorCategoria = {};
  
  gastosDoMes.forEach(gasto => {
    if (!totalPorCategoria[gasto.categoria]) {
      totalPorCategoria[gasto.categoria] = 0;
    }
    totalPorCategoria[gasto.categoria] += gasto.valor;
  });
  
  const alertas = [];
  
  for (const [categoria, limite] of Object.entries(orcamentos)) {
    const gasto = totalPorCategoria[categoria] || 0;
    const percentual = (gasto / limite) * 100;
    
    if (percentual >= 90 && percentual < 100) {
      alertas.push(`‚ö†Ô∏è Voc√™ j√° usou ${percentual.toFixed(0)}% do or√ßamento de ${categoria} (R$${gasto.toFixed(2)} de R$${limite.toFixed(2)})`);
    } else if (percentual >= 100) {
      alertas.push(`üö® ALERTA: Or√ßamento de ${categoria} EXCEDIDO! (R$${gasto.toFixed(2)} de R$${limite.toFixed(2)})`);
    }
  }
  
  return alertas;
}

// Fun√ß√£o para gerar insights sobre gastos
function gerarInsights() {
  const insights = [];
  
  // Verifica se h√° gastos suficientes para an√°lise
  if (gastos.length < 5) {
    return ['Registre mais gastos para receber insights personalizados.'];
  }
  
  // Categoria com maior gasto no m√™s
  const gastosDoMes = gastosPorPeriodo('mes');
  const totalPorCategoria = {};
  
  gastosDoMes.forEach(gasto => {
    if (!totalPorCategoria[gasto.categoria]) {
      totalPorCategoria[gasto.categoria] = 0;
    }
    totalPorCategoria[gasto.categoria] += gasto.valor;
  });
  
  let maiorCategoria = '';
  let maiorValor = 0;
  
  for (const [categoria, valor] of Object.entries(totalPorCategoria)) {
    if (valor > maiorValor) {
      maiorValor = valor;
      maiorCategoria = categoria;
    }
  }
  
  if (maiorCategoria) {
    insights.push(`üìä Seu maior gasto este m√™s foi com ${maiorCategoria}: R$${maiorValor.toFixed(2)}`);
  }
  
  // Compara√ß√£o com m√™s anterior
  const mesAtual = moment().month();
  const mesAnterior = moment().subtract(1, 'month').month();
  
  const gastosAtual = gastos.filter(g => moment(g.data).month() === mesAtual);
  const gastosAnterior = gastos.filter(g => moment(g.data).month() === mesAnterior);
  
  const totalAtual = gastosAtual.reduce((soma, g) => soma + g.valor, 0);
  const totalAnterior = gastosAnterior.reduce((soma, g) => soma + g.valor, 0);
  
  if (gastosAnterior.length > 0) {
    const diferenca = totalAtual - totalAnterior;
    const percentual = (Math.abs(diferenca) / totalAnterior) * 100;
    
    if (diferenca > 0) {
      insights.push(`üìà Seus gastos aumentaram ${percentual.toFixed(0)}% em rela√ß√£o ao m√™s anterior.`);
    } else if (diferenca < 0) {
      insights.push(`üìâ Seus gastos diminu√≠ram ${percentual.toFixed(0)}% em rela√ß√£o ao m√™s anterior. Parab√©ns!`);
    } else {
      insights.push(`üîÑ Seus gastos est√£o est√°veis em rela√ß√£o ao m√™s anterior.`);
    }
  }
  
  return insights;
}

// Fun√ß√£o para salvar dados
function salvarDados(tipo, dados) {
  try {
    fs.writeFileSync(`${tipo}.json`, JSON.stringify(dados, null, 2));
    console.log(`‚úÖ Dados de ${tipo} salvos com sucesso`);
    return true;
  } catch (error) {
    console.error(`‚ùå Erro ao salvar dados de ${tipo}:`, error);
    return false;
  }
}

/* === Mensagens === */
client.on('message_create', async (msg) => {
  try {
    // Verifica se √© a primeira mensagem do pr√≥prio usu√°rio e configura o chat pr√≥prio
    if (msg.fromMe && !chatProprio) {
      chatProprio = msg.from;
      salvarDados('chat_proprio', { chatId: chatProprio });
      console.log('‚úÖ Chat pr√≥prio configurado:', chatProprio);
      await msg.reply(`‚úÖ Este chat foi configurado como seu chat principal com o bot. Agora o bot s√≥ responder√° √†s suas mensagens neste chat.`);
      return;
    }
    
    // Verifica se a mensagem √© do pr√≥prio usu√°rio no chat pr√≥prio ou de um contato permitido
    const remetente = msg.from; // N√∫mero do remetente no formato 'XXXXXXXXXXX@c.us'
    const numeroRemetente = remetente ? remetente.split('@')[0] : '';
    
    // Ignora mensagens do pr√≥prio usu√°rio em outros chats
    if (msg.fromMe && chatProprio && remetente !== chatProprio) {
      console.log(`Mensagem ignorada do pr√≥prio usu√°rio em outro chat: ${remetente}`);
      return;
    }
    
    // Ignora mensagens de contatos n√£o permitidos
    if (!msg.fromMe && !contatosPermitidos.includes(numeroRemetente)) {
      console.log(`Mensagem ignorada de ${numeroRemetente} (n√£o est√° na lista de permitidos)`);
      return;
    }

    const texto = msg.body.toLowerCase();
    console.log('Recebido:', texto, 'de:', msg.fromMe ? 'mim mesmo' : numeroRemetente);    // debug

    /* --- Comandos de administra√ß√£o --- */
    // Adicionar contato √† lista de permitidos (apenas o pr√≥prio usu√°rio pode fazer isso)
    if (msg.fromMe && texto.startsWith('permitir ')) {
      const numeroParaAdicionar = texto.replace('permitir ', '').trim();
      if (numeroParaAdicionar && !contatosPermitidos.includes(numeroParaAdicionar)) {
        contatosPermitidos.push(numeroParaAdicionar);
        salvarDados('contatos_permitidos', contatosPermitidos);
        await msg.reply(`‚úÖ Contato ${numeroParaAdicionar} adicionado √† lista de permitidos.`);
      } else {
        await msg.reply(`‚ö†Ô∏è Contato j√° est√° na lista ou n√∫mero inv√°lido.`);
      }
      return;
    }

    // Remover contato da lista de permitidos (apenas o pr√≥prio usu√°rio pode fazer isso)
    if (msg.fromMe && texto.startsWith('remover ')) {
      const numeroParaRemover = texto.replace('remover ', '').trim();
      const index = contatosPermitidos.indexOf(numeroParaRemover);
      if (index > -1) {
        contatosPermitidos.splice(index, 1);
        salvarDados('contatos_permitidos', contatosPermitidos);
        await msg.reply(`‚úÖ Contato ${numeroParaRemover} removido da lista de permitidos.`);
      } else {
        await msg.reply(`‚ö†Ô∏è Contato n√£o encontrado na lista.`);
      }
      return;
    }

    // Listar contatos permitidos (apenas o pr√≥prio usu√°rio pode fazer isso)
    if (msg.fromMe && texto === 'listar permitidos') {
      if (contatosPermitidos.length === 0) {
        await msg.reply('üì≠ Nenhum contato na lista de permitidos.');
      } else {
        let lista = 'üìã Contatos permitidos:\n\n';
        contatosPermitidos.forEach((numero, i) => {
          lista += `${i + 1}. ${numero}\n`;
        });
        await msg.reply(lista);
      }
      return;
    }

    // Configurar chat pr√≥prio (apenas o pr√≥prio usu√°rio pode fazer isso)
    if (msg.fromMe && texto === 'configurar chat') {
      chatProprio = msg.from;
      salvarDados('chat_proprio', { chatId: chatProprio });
      await msg.reply(`‚úÖ Este chat foi configurado como seu chat principal com o bot. Agora o bot s√≥ responder√° √†s suas mensagens neste chat.`);
      return;
    }

    /* --- Registrar gasto por texto --- */
    const regexGasto = /gastei\s*r?\$?\s*(\d+[.,]?\d*)\s+com\s+(.+)/i;
    const matchGasto = texto.match(regexGasto);
    if (matchGasto) {
      const valor = parseFloat(matchGasto[1].replace(',', '.'));
      let categoria = matchGasto[2].trim();
      
      // Tenta categorizar automaticamente
      const categoriaAutomatica = categorizarGasto(categoria);
      if (categoriaAutomatica !== 'outros') {
        categoria = categoriaAutomatica;
      }

      const entrada = { 
        valor, 
        categoria, 
        data: new Date().toISOString(),
        autor: msg.fromMe ? 'eu' : numeroRemetente,
        tipo: 'texto'
      };
      gastos.push(entrada);
      salvarDados('gastos', gastos);

      let resposta = `üí∏ Gasto registrado: R$${valor.toFixed(2)} com ${categoria}`;
      
      // Verifica or√ßamentos
      const alertas = verificarOrcamentos();
      if (alertas.length > 0) {
        resposta += '\n\n' + alertas.join('\n');
      }

      await msg.reply(resposta);
      return;
    }

    /* --- Registrar receita --- */
    const regexReceita = /recebi\s*r?\$?\s*(\d+[.,]?\d*)\s+(?:de|com)\s+(.+)/i;
    const matchReceita = texto.match(regexReceita);
    if (matchReceita) {
      const valor = parseFloat(matchReceita[1].replace(',', '.'));
      const fonte = matchReceita[2].trim();

      const entrada = { 
        valor, 
        categoria: 'receita',
        fonte,
        data: new Date().toISOString(),
        autor: msg.fromMe ? 'eu' : numeroRemetente,
        tipo: 'receita'
      };
      gastos.push(entrada);
      salvarDados('gastos', gastos);

      await msg.reply(`üí∞ Receita registrada: R$${valor.toFixed(2)} de ${fonte}`);
      return;
    }

    /* --- Registrar gasto por foto --- */
    if (msg.hasMedia && texto.includes('comprovante')) {
      try {
        const media = await msg.downloadMedia();
        
        // Salvar a imagem
        const timestamp = Date.now();
        const filename = `comprovante_${timestamp}.${media.mimetype.split('/')[1]}`;
        const filepath = path.join(diretorioComprovantes, filename);
        
        fs.writeFileSync(filepath, Buffer.from(media.data, 'base64'));
        
        // Registrar o gasto (valor padr√£o at√© que o usu√°rio especifique)
        const entrada = { 
          valor: 0, // Valor tempor√°rio
          categoria: 'outros',
          data: new Date().toISOString(),
          autor: msg.fromMe ? 'eu' : numeroRemetente,
          tipo: 'comprovante',
          comprovante: filename
        };
        
        gastos.push(entrada);
        salvarDados('gastos', gastos);
        
        await msg.reply(`üì∏ Comprovante salvo! Por favor, informe o valor e a categoria usando o comando:\n*valor comprovante R$XX.XX categoria*`);
      } catch (error) {
        console.error('Erro ao processar comprovante:', error);
        await msg.reply('‚ùå Erro ao processar o comprovante. Tente novamente.');
      }
      return;
    }

    /* --- Atualizar valor e categoria do √∫ltimo comprovante --- */
    const regexComprovante = /valor\s+comprovante\s*r?\$?\s*(\d+[.,]?\d*)\s+(.+)/i;
    const matchComprovante = texto.match(regexComprovante);
    if (matchComprovante) {
      // Encontrar o √∫ltimo gasto do tipo comprovante
      const index = gastos.map(g => g.tipo).lastIndexOf('comprovante');
      
      if (index !== -1) {
        const valor = parseFloat(matchComprovante[1].replace(',', '.'));
        let categoria = matchComprovante[2].trim();
        
        // Tenta categorizar automaticamente
        const categoriaAutomatica = categorizarGasto(categoria);
        if (categoriaAutomatica !== 'outros') {
          categoria = categoriaAutomatica;
        }
        
        gastos[index].valor = valor;
        gastos[index].categoria = categoria;
        
        salvarDados('gastos', gastos);
        
        let resposta = `‚úÖ Comprovante atualizado: R$${valor.toFixed(2)} com ${categoria}`;
        
        // Verifica or√ßamentos
        const alertas = verificarOrcamentos();
        if (alertas.length > 0) {
          resposta += '\n\n' + alertas.join('\n');
        }
        
        await msg.reply(resposta);
      } else {
        await msg.reply('‚ùå Nenhum comprovante recente encontrado para atualizar.');
      }
      return;
    }

    /* --- Definir or√ßamento --- */
    const regexOrcamento = /(?:definir|criar)\s+or[√ßc]amento\s+(?:de|para)\s+(.+)\s+r?\$?\s*(\d+[.,]?\d*)/i;
    const matchOrcamento = texto.match(regexOrcamento);
    if (matchOrcamento) {
      const categoria = matchOrcamento[1].trim().toLowerCase();
      const valor = parseFloat(matchOrcamento[2].replace(',', '.'));
      
      orcamentos[categoria] = valor;
      salvarDados('orcamentos', orcamentos);
      
      await msg.reply(`‚úÖ Or√ßamento definido: R$${valor.toFixed(2)} para ${categoria}`);
      return;
    }

    /* --- Adicionar palavra-chave a uma categoria --- */
    const regexCategoria = /adicionar\s+(.+)\s+(?:√†|a|na)\s+categoria\s+(.+)/i;
    const matchCategoria = texto.match(regexCategoria);
    if (matchCategoria) {
      const palavraChave = matchCategoria[1].trim().toLowerCase();
      const categoria = matchCategoria[2].trim().toLowerCase();
      
      if (!categorias[categoria]) {
        categorias[categoria] = [];
      }
      
      if (!categorias[categoria].includes(palavraChave)) {
        categorias[categoria].push(palavraChave);
        salvarDados('categorias', categorias);
        await msg.reply(`‚úÖ Palavra-chave "${palavraChave}" adicionada √† categoria "${categoria}"`);
      } else {
        await msg.reply(`‚ö†Ô∏è Palavra-chave "${palavraChave}" j√° existe na categoria "${categoria}"`);
      }
      return;
    }

    /* --- Resumo --- */
    if (texto === 'resumo') {
      if (gastos.length === 0) {
        await msg.reply('üì≠ Nenhum gasto registrado ainda.');
      } else {
        const gastosRecentes = gastos.filter(g => g.tipo !== 'receita');
        const receitas = gastos.filter(g => g.tipo === 'receita');
        
        const totalGastos = gastosRecentes.reduce((soma, g) => soma + g.valor, 0);
        const totalReceitas = receitas.reduce((soma, g) => soma + g.valor, 0);
        const saldo = totalReceitas - totalGastos;
        
        let resumo = `üìä *RESUMO FINANCEIRO*\n\n`;
        resumo += `üí∞ Total de receitas: R$${totalReceitas.toFixed(2)}\n`;
        resumo += `üí∏ Total de gastos: R$${totalGastos.toFixed(2)}\n`;
        resumo += `${saldo >= 0 ? '‚úÖ' : '‚ùå'} Saldo: R$${saldo.toFixed(2)}\n\n`;
        
        resumo += `*√öltimos 5 gastos:*\n`;
        const ultimosGastos = [...gastosRecentes].sort((a, b) => new Date(b.data) - new Date(a.data)).slice(0, 5);
        
        ultimosGastos.forEach((g, i) => {
          const data = formatarData(g.data);
          const autorTexto = g.autor ? ` (por ${g.autor === 'eu' ? 'voc√™' : g.autor})` : '';
          resumo += `${i + 1}. ${data} - ${g.categoria}: R$${g.valor.toFixed(2)}${autorTexto}\n`;
        });
        
        await msg.reply(resumo);
      }
      return;
    }

    /* --- Resumo por categoria --- */
    if (texto === 'resumo por categoria') {
      if (gastos.length === 0) {
        await msg.reply('üì≠ Nenhum gasto registrado ainda.');
      } else {
        const gastosRecentes = gastos.filter(g => g.tipo !== 'receita');
        const totalPorCategoria = {};
        
        gastosRecentes.forEach(gasto => {
          if (!totalPorCategoria[gasto.categoria]) {
            totalPorCategoria[gasto.categoria] = 0;
          }
          totalPorCategoria[gasto.categoria] += gasto.valor;
        });
        
        let resumo = `üìä *GASTOS POR CATEGORIA*\n\n`;
        
        // Ordenar categorias por valor (do maior para o menor)
        const categorias = Object.entries(totalPorCategoria)
          .sort((a, b) => b[1] - a[1])
          .map(([categoria, valor]) => `${categoria}: R$${valor.toFixed(2)}`);
        
        resumo += categorias.join('\n');
        
        await msg.reply(resumo);
      }
      return;
    }

    /* --- Resumo por per√≠odo --- */
    const regexPeriodo = /resumo\s+(hoje|semana|m[√™e]s|ano)/i;
    const matchPeriodo = texto.match(regexPeriodo);
    if (matchPeriodo) {
      const periodo = matchPeriodo[1].toLowerCase().replace('√™', 'e');
      
      const gastosNoPeriodo = gastosPorPeriodo(periodo).filter(g => g.tipo !== 'receita');
      
      if (gastosNoPeriodo.length === 0) {
        await msg.reply(`üì≠ Nenhum gasto registrado para ${periodo}.`);
      } else {
        const total = gastosNoPeriodo.reduce((soma, g) => soma + g.valor, 0);
        
        let resumo = `üìä *RESUMO DE ${periodo.toUpperCase()}*\n\n`;
        resumo += `Total: R$${total.toFixed(2)}\n\n`;
        
        // Agrupar por categoria
        const porCategoria = {};
        gastosNoPeriodo.forEach(gasto => {
          if (!porCategoria[gasto.categoria]) {
            porCategoria[gasto.categoria] = 0;
          }
          porCategoria[gasto.categoria] += gasto.valor;
        });
        
        // Ordenar categorias por valor
        const categorias = Object.entries(porCategoria)
          .sort((a, b) => b[1] - a[1])
          .map(([categoria, valor]) => {
            const percentual = (valor / total) * 100;
            return `${categoria}: R$${valor.toFixed(2)} (${percentual.toFixed(0)}%)`;
          });
        
        resumo += categorias.join('\n');
        
        await msg.reply(resumo);
      }
      return;
    }

    /* --- Insights --- */
    if (texto === 'insights' || texto === 'dicas') {
      const insights = gerarInsights();
      
      if (insights.length === 0) {
        await msg.reply('üìä Registre mais gastos para receber insights personalizados.');
      } else {
        await msg.reply(`üìä *INSIGHTS FINANCEIROS*\n\n${insights.join('\n\n')}`);
      }
      return;
    }

    /* --- Or√ßamentos --- */
    if (texto === 'or√ßamentos' || texto === 'orcamentos') {
      if (Object.keys(orcamentos).length === 0) {
        await msg.reply('üì≠ Nenhum or√ßamento definido ainda. Use "definir or√ßamento para CATEGORIA R$XX" para criar.');
      } else {
        const gastosDoMes = gastosPorPeriodo('mes');
        const totalPorCategoria = {};
        
        gastosDoMes.forEach(gasto => {
          if (!totalPorCategoria[gasto.categoria]) {
            totalPorCategoria[gasto.categoria] = 0;
          }
          totalPorCategoria[gasto.categoria] += gasto.valor;
        });
        
        let resumo = `üìä *OR√áAMENTOS DO M√äS*\n\n`;
        
        for (const [categoria, limite] of Object.entries(orcamentos)) {
          const gasto = totalPorCategoria[categoria] || 0;
          const percentual = (gasto / limite) * 100;
          const status = percentual >= 100 ? 'üö®' : percentual >= 90 ? '‚ö†Ô∏è' : '‚úÖ';
          
          resumo += `${status} ${categoria}: R$${gasto.toFixed(2)} de R$${limite.toFixed(2)} (${percentual.toFixed(0)}%)\n`;
        }
        
        await msg.reply(resumo);
      }
      return;
    }

    /* --- Excluir √∫ltimo gasto --- */
    if (texto === 'excluir √∫ltimo' || texto === 'excluir ultimo') {
      if (gastos.length === 0) {
        await msg.reply('üì≠ Nenhum gasto registrado para excluir.');
      } else {
        const ultimoGasto = gastos.pop();
        salvarDados('gastos', gastos);
        
        await msg.reply(`‚úÖ √öltimo registro exclu√≠do: R$${ultimoGasto.valor.toFixed(2)} com ${ultimoGasto.categoria}`);
      }
      return;
    }

    /* --- Ranking de gastos --- */
    if (texto === 'ranking' || texto === 'ranking de gastos') {
      if (gastos.length === 0) {
        await msg.reply('üì≠ Nenhum gasto registrado ainda.');
      } else {
        const gastosDoMes = gastosPorPeriodo('mes').filter(g => g.tipo !== 'receita');
        
        if (gastosDoMes.length === 0) {
          await msg.reply('üì≠ Nenhum gasto registrado este m√™s.');
          return;
        }
        
        // Agrupar por categoria
        const porCategoria = {};
        gastosDoMes.forEach(gasto => {
          if (!porCategoria[gasto.categoria]) {
            porCategoria[gasto.categoria] = 0;
          }
          porCategoria[gasto.categoria] += gasto.valor;
        });
        
        // Ordenar categorias por valor
        const ranking = Object.entries(porCategoria)
          .sort((a, b) => b[1] - a[1]);
        
        let resposta = `üèÜ *RANKING DE GASTOS DO M√äS*\n\n`;
        
        ranking.forEach((item, index) => {
          const [categoria, valor] = item;
          const medal = index === 0 ? 'ü•á' : index === 1 ? 'ü•à' : index === 2 ? 'ü•â' : `${index + 1}.`;
          resposta += `${medal} ${categoria}: R$${valor.toFixed(2)}\n`;
        });
        
        await msg.reply(resposta);
      }
      return;
    }

    /* --- Status do servidor --- */
    if (texto === 'status' || texto === 'status servidor') {
      const uptime = process.uptime();
      const dias = Math.floor(uptime / 86400);
      const horas = Math.floor((uptime % 86400) / 3600);
      const minutos = Math.floor((uptime % 3600) / 60);
      
      let status = `üñ•Ô∏è *STATUS DO SERVIDOR*\n\n`;
      status += `‚úÖ Bot est√° online\n`;
      status += `‚è±Ô∏è Tempo de atividade: ${dias}d ${horas}h ${minutos}m\n`;
      status += `üìä Gastos registrados: ${gastos.length}\n`;
      status += `üë• Contatos permitidos: ${contatosPermitidos.length}\n`;
      status += `üíæ Vers√£o do Node.js: ${process.version}\n`;
      
      await msg.reply(status);
      return;
    }

    /* --- Ajuda --- */
    if (texto === 'ajuda') {
      let mensagemAjuda = `ü§ñ *COMANDOS DISPON√çVEIS*\n\n`;
      
      mensagemAjuda += `*Registrar Transa√ß√µes:*\n`;
      mensagemAjuda += `- *Gastei R$XX com YYY* ‚Üí Registra um gasto\n`;
      mensagemAjuda += `- *Recebi R$XX de YYY* ‚Üí Registra uma receita\n`;
      mensagemAjuda += `- Envie uma foto com a palavra *comprovante* ‚Üí Registra gasto com comprovante\n`;
      mensagemAjuda += `- *Valor comprovante R$XX categoria* ‚Üí Define valor e categoria do √∫ltimo comprovante\n\n`;
      
      mensagemAjuda += `*Consultas:*\n`;
      mensagemAjuda += `- *Resumo* ‚Üí Mostra resumo geral\n`;
      mensagemAjuda += `- *Resumo por categoria* ‚Üí Mostra gastos agrupados por categoria\n`;
      mensagemAjuda += `- *Resumo hoje/semana/m√™s/ano* ‚Üí Mostra gastos do per√≠odo\n`;
      mensagemAjuda += `- *Ranking* ‚Üí Mostra ranking de gastos por categoria\n`;
      mensagemAjuda += `- *Insights* ‚Üí Receba dicas personalizadas\n`;
      mensagemAjuda += `- *Or√ßamentos* ‚Üí Veja seus or√ßamentos e limites\n\n`;
      
      mensagemAjuda += `*Configura√ß√µes:*\n`;
      mensagemAjuda += `- *Definir or√ßamento para CATEGORIA R$XX* ‚Üí Cria limite de gastos\n`;
      mensagemAjuda += `- *Adicionar PALAVRA √† categoria CATEGORIA* ‚Üí Personaliza categoriza√ß√£o\n`;
      mensagemAjuda += `- *Excluir √∫ltimo* ‚Üí Remove o √∫ltimo registro\n`;
      mensagemAjuda += `- *Configurar chat* ‚Üí Define este chat como principal\n`;
      mensagemAjuda += `- *Status* ‚Üí Verifica status do servidor\n`;

      // Adiciona comandos de administra√ß√£o apenas para o pr√≥prio usu√°rio
      if (msg.fromMe) {
        mensagemAjuda += `\nüëë *Comandos de Administra√ß√£o:*\n`;
        mensagemAjuda += `- *Permitir N√öMERO* ‚Üí Adiciona contato √† lista de permitidos\n`;
        mensagemAjuda += `- *Remover N√öMERO* ‚Üí Remove contato da lista de permitidos\n`;
        mensagemAjuda += `- *Listar permitidos* ‚Üí Mostra todos os contatos permitidos\n`;
      }

      await msg.reply(mensagemAjuda);
      return;
    }
  } catch (error) {
    console.error('Erro ao processar mensagem:', error);
    try {
      await msg.reply('‚ùå Ocorreu um erro ao processar sua mensagem. Por favor, tente novamente.');
    } catch (replyError) {
      console.error('Erro ao enviar mensagem de erro:', replyError);
    }
  }
});

// Inicializar o cliente
client.initialize();

// Exportar o cliente para uso em outros m√≥dulos
module.exports = client;
